<section class="computed-signal">
  <h2>Computed Signal Demo</h2>

  <div class="controls">
    <button class="btn btn-primary" (click)="decrement()">-</button>
    <button class="btn btn-primary" (click)="increment()">+</button>
    <button class="btn btn-ghost" (click)="reset()">Reset</button>
  </div>

  <div class="values">
    <p>count: <strong>{{ count() }}</strong></p>
    <p>double (computed): <strong>{{ double() }}</strong></p>
    <p>triple (computed): <strong>{{ triple() }}</strong></p>
    <p>isEven (computed): <strong>{{ isEven() ? 'yes' : 'no' }}</strong></p>
  </div>

  <section class="docs" aria-labelledby="computed-docs" ngNonBindable>
    <h3 id="computed-docs">Notes & examples</h3>
    <p>This component demonstrates <em>computed</em> signals derived from a base <code>signal</code>.</p>

    <h4>Key patterns</h4>
    <ul>
      <li>Use <code>computed(() =&gt; ...)</code> to create derived values that update automatically when their dependencies change.</li>
      <li>Keep base state minimal and derive everything else via <code>computed</code> where appropriate.</li>
      <li>Computed signals are lazy and cached until their dependencies change.</li>
    </ul>

    <h4>Example</h4>
    <pre><code>// base writable signal
count = signal(1);

// computed derived signal
double = computed(() =&gt; count() * 2);

// update
count.update(n =&gt; n + 1);
</code></pre>

    <p>See Angular Signals docs for advanced usages (memoization, effects, derived signals).</p>
  </section>
</section>

